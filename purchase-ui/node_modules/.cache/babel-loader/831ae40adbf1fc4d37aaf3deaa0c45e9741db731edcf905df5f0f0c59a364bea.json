{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(a, b) {\n  var c = Object.keys(a);\n  if (Object.getOwnPropertySymbols) {\n    var d = Object.getOwnPropertySymbols(a);\n    b && (d = d.filter(function (b) {\n      return Object.getOwnPropertyDescriptor(a, b).enumerable;\n    })), c.push.apply(c, d);\n  }\n  return c;\n}\nfunction _objectSpread(a) {\n  for (var b, c = 1; c < arguments.length; c++) b = null == arguments[c] ? {} : arguments[c], c % 2 ? ownKeys(Object(b), !0).forEach(function (c) {\n    _defineProperty(a, c, b[c]);\n  }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(a, Object.getOwnPropertyDescriptors(b)) : ownKeys(Object(b)).forEach(function (c) {\n    Object.defineProperty(a, c, Object.getOwnPropertyDescriptor(b, c));\n  });\n  return a;\n}\nimport React from \"react\";\nimport { isNotNil, isNumber, isString } from \"../../utils/type-guards\";\nexport var Order = {\n  ASC: \"ASC\",\n  asc: \"asc\",\n  DESC: \"DESC\",\n  desc: \"desc\"\n};\nexport var getColumnsSize = function (a) {\n  return a.map(function (a) {\n    return isNumber(a) ? \"\".concat(a, \"px\") : \"auto\";\n  }).join(\" \");\n};\nexport var getColumnLeftOffset = function (a) {\n  var b = a.columnIndex,\n    c = a.resizedColumnWidths,\n    d = a.initialColumnWidths,\n    e = d.slice(0, b).map(function (a, b) {\n      return c[b] || a;\n    });\n  return e.reduce(function (a, b) {\n    return a + b;\n  }, 0);\n};\nexport var createSortingState = function (a, b, c) {\n  return isString(b) ? {\n    by: a,\n    order: b.toLowerCase(),\n    sortFn: c\n  } : null;\n};\nexport var getNewSorting = function (a, b, c) {\n  return a && a.by === b ? \"asc\" === a.order ? {\n    by: b,\n    order: \"desc\",\n    sortFn: c\n  } : null : {\n    by: b,\n    order: \"asc\",\n    sortFn: c\n  };\n};\nexport var getMaxLevel = function (a) {\n  var b = 0,\n    c = function (a) {\n      var d = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1;\n      d > b && (b = d), a.forEach(function (a) {\n        a.columns && c(a.columns, d + 1);\n      });\n    };\n  return c(a), b;\n};\nvar getLastChildrenCount = function (a) {\n  var b = 0,\n    c = function (a) {\n      a.forEach(function (a) {\n        a.columns ? c(a.columns) : b++;\n      });\n    };\n  return c(a), b;\n};\nexport var transformColumns = function (a, b) {\n  for (var c = [{\n      columns: a,\n      index: 0\n    }], d = [], e = 0; c.length;) {\n    var f = c.length - 1,\n      g = c[f],\n      h = g.columns[g.index];\n    h ? function (a) {\n      d[f] || (d[f] = []);\n      var i = c[0].index,\n        j = d[f][d[f].length - 1],\n        k = j ? j.position.gridIndex + (j.position.colSpan || 1) : 0,\n        l = 0 === f ? e++ : null !== (a = h.colId) && void 0 !== a ? a : 0,\n        m = _objectSpread(_objectSpread({}, h), {}, {\n          position: {\n            topHeaderGridIndex: i,\n            gridIndex: k,\n            level: f\n          }\n        });\n      0 === f && (m.colId = l), m.columns ? (m.position.colSpan = getLastChildrenCount(m.columns), d[f].push(m), c.push({\n        columns: m.columns.map(function (a) {\n          return _objectSpread(_objectSpread({}, a), {}, {\n            colId: e++,\n            parentId: l\n          });\n        }),\n        index: 0\n      })) : (m.position.rowSpan = b - f, d[f].push(m), g.index++);\n    }() : (c.pop(), c[c.length - 1] && c[c.length - 1].index++);\n  }\n  return d;\n};\nvar getIsFirst = function (a, b) {\n  var c,\n    d,\n    e = b.colId,\n    f = b.parentId,\n    g = b.position,\n    h = b.accessor;\n  if (0 === g.level) return 0 === e;\n  var i = a.find(function (a) {\n    return a.colId === f;\n  });\n  return !!((null === i || void 0 === i || null === (c = i.columns) || void 0 === c || null === (d = c[0]) || void 0 === d ? void 0 : d.accessor) === h && !!i && getIsFirst(a, i));\n};\nexport var useHeaderData = function (a) {\n  var b = React.useRef({}),\n    c = transformColumns(a, getMaxLevel(a)),\n    d = Object.values(b.current).filter(isNotNil).map(function (a) {\n      return a.getBoundingClientRect().height;\n    }),\n    e = c.flat().filter(function (a) {\n      return !a.hidden;\n    }).map(function (a, b, e) {\n      return _objectSpread(_objectSpread({}, a), {}, {\n        position: _objectSpread(_objectSpread({}, a.position), {}, {\n          isFirst: getIsFirst(e, a),\n          smallTextSize: 1 < c.length && a.position.level === c.length - 1,\n          height: d[b] || 0\n        })\n      });\n    }),\n    f = c.map(function (a, b) {\n      return Math.min.apply(null, e.filter(function (a) {\n        return a.position.level === b;\n      }).map(function (a) {\n        return a.position.height;\n      }));\n    }),\n    g = e.filter(function (a) {\n      var b = a.position.colSpan;\n      return !b;\n    }).sort(function (c, a) {\n      return c.position.topHeaderGridIndex === a.position.topHeaderGridIndex ? c.position.gridIndex > a.position.gridIndex ? 1 : -1 : c.position.topHeaderGridIndex > a.position.topHeaderGridIndex ? 1 : -1;\n    }),\n    h = g.map(function (a, b) {\n      var c,\n        d,\n        e = f.reduce(function (c, a) {\n          return c + a;\n        }, 0);\n      return (a.position.rowSpan || 0) >= ((null === (c = g[b + 1]) || void 0 === c ? void 0 : c.position.rowSpan) || 0) ? e - (a.position.height || 0) : e - (null === (d = g[b + 1]) || void 0 === d ? void 0 : d.position.height) || 0;\n    });\n  return {\n    headers: c,\n    flattenedHeaders: e,\n    lowHeaders: g,\n    headerRowsRefs: b,\n    headerRowsHeights: f,\n    headerColumnsHeights: d,\n    resizerTopOffsets: h\n  };\n};\nexport var useLazyLoadData = function (a, b, c) {\n  var d = React.useState(0),\n    e = _slicedToArray(d, 2),\n    f = e[0],\n    g = e[1],\n    h = React.useRef(null),\n    i = React.useRef(null),\n    j = Math.floor(a / 3);\n  React.useEffect(function () {\n    if (c) {\n      var a = 0;\n      b && \"offsetHeight\" in b ? a = b.offsetHeight : b && \"outerHeight\" in b && (a = b.outerHeight);\n      var d = function () {\n        i.current && a / 2 > i.current.getBoundingClientRect().top ? g(function (a) {\n          return a + j;\n        }) : h.current && h.current.getBoundingClientRect().top > a / 2 && g(function (a) {\n          return 0 > a - j ? 0 : a - j;\n        });\n      };\n      return null === b || void 0 === b ? void 0 : b.addEventListener(\"scroll\", d), function () {\n        return null === b || void 0 === b ? void 0 : b.removeEventListener(\"scroll\", d);\n      };\n    }\n  }, [f, b]);\n  return {\n    getSlicedRows: function getSlicedRows(b) {\n      return !c || b.length < a ? b : b.slice(f, f + a);\n    },\n    setBoundaryRef: function setBoundaryRef(b, d) {\n      return c && 0 === b && d === j && 0 < f ? h : c && 0 === b && d === a - j ? i : void 0;\n    }\n  };\n};\nexport var transformRows = function (a, b, c) {\n  for (var d = [{\n      rows: a,\n      index: 0\n    }], e = []; d.length;) {\n    var f = d.length - 1,\n      g = d[f],\n      h = g.rows[g.index];\n    if (h) {\n      var i = _objectSpread(_objectSpread({}, h), {}, {\n          options: {\n            level: f\n          },\n          rows: h.rows && _toConsumableArray(h.rows)\n        }),\n        j = !!i.rows && (c || b.includes(i.id));\n      j ? d.push({\n        rows: i.rows,\n        index: 0\n      }) : g.index++, e.push(i);\n    } else d.pop(), d[d.length - 1] && d[d.length - 1].index++;\n  }\n  return e;\n};\nexport function getMergedArray(a, b) {\n  for (var c = Math.max(a.length, b.length), d = [], e = 0; e < c; e++) {\n    var f;\n    d.push(null !== (f = b[e]) && void 0 !== f ? f : a[e]);\n  }\n  return d;\n}\nexport function calulateColSpans(a, b) {\n  var c = [],\n    d = 0,\n    e = a.length,\n    f = function (a, b) {\n      return b + a > e ? e - b - a : a;\n    };\n  return a.forEach(function (a) {\n    var e = a.colSpan,\n      g = 1 < c.length ? c.reduce(function (c, a) {\n        return c + a;\n      }) : 0;\n    if (\"number\" == typeof e || \"function\" == typeof e) {\n      var h = \"number\" == typeof e ? e : e(b);\n      0 === d ? c.push(f(h, g)) : c.push(f(h - d || 0, g)), d = 0 < h - d ? h - 1 : d - h;\n    } else 0 === d ? c.push(f(1, g)) : (c.push(0), d--);\n  }), c;\n}","map":{"version":3,"names":["React","isNotNil","isNumber","isString","Order","ASC","asc","DESC","desc","getColumnsSize","a","map","concat","join","getColumnLeftOffset","b","columnIndex","c","resizedColumnWidths","d","initialColumnWidths","e","slice","reduce","createSortingState","by","order","toLowerCase","sortFn","getNewSorting","getMaxLevel","traverse","arguments","length","forEach","columns","getLastChildrenCount","transformColumns","index","f","g","h","i","j","k","position","gridIndex","colSpan","l","colId","m","_objectSpread","topHeaderGridIndex","level","push","parentId","rowSpan","pop","getIsFirst","accessor","find","useHeaderData","useRef","Object","values","current","filter","getBoundingClientRect","height","flat","hidden","isFirst","smallTextSize","Math","min","apply","sort","headers","flattenedHeaders","lowHeaders","headerRowsRefs","headerRowsHeights","headerColumnsHeights","resizerTopOffsets","useLazyLoadData","useState","_slicedToArray","floor","useEffect","offsetHeight","outerHeight","onScrollListener","top","addEventListener","removeEventListener","getSlicedRows","setBoundaryRef","transformRows","rows","options","_toConsumableArray","includes","id","getMergedArray","max","calulateColSpans","getAvailableSpan"],"sources":["/Users/leonofv/Desktop/purchase-ui/node_modules/@consta/src/components/Table/helpers.ts"],"sourcesContent":["import React from 'react';\n\nimport { isNotNil, isNumber, isString } from '../../utils/type-guards';\nimport {\n  ColumnWidth,\n  SortingState,\n  TableColumn,\n  TableRow,\n  TableTreeRow,\n} from './Table';\n\nexport const Order = {\n  ASC: 'ASC',\n  asc: 'asc',\n  DESC: 'DESC',\n  desc: 'desc',\n} as const;\n\nexport type OrderType = typeof Order[keyof typeof Order];\n\nexport type Position = {\n  colSpan?: number;\n  rowSpan?: number;\n  level: number;\n  gridIndex: number;\n  isFirst?: boolean;\n  topHeaderGridIndex: number;\n  smallTextSize?: boolean;\n  height?: number;\n};\n\nexport type Header<T extends TableRow> = TableColumn<T> & {\n  position: Position;\n  colId?: number;\n  parentId?: number;\n};\n\nexport type HeaderData<T extends TableRow> = {\n  headers: Array<Header<T>>[];\n  flattenedHeaders: Array<Header<T>>;\n  lowHeaders: Array<Header<T>>;\n  headerRowsRefs: React.MutableRefObject<Record<number, HTMLDivElement | null>>;\n  headerRowsHeights: Array<number>;\n  headerColumnsHeights: Array<number>;\n  resizerTopOffsets: Array<number>;\n};\n\nexport const getColumnsSize = (sizes: ColumnWidth[]): string => {\n  return sizes.map((s) => (isNumber(s) ? `${s}px` : `auto`)).join(' ');\n};\n\nexport const getColumnLeftOffset = ({\n  columnIndex,\n  resizedColumnWidths,\n  initialColumnWidths,\n}: {\n  columnIndex: number;\n  resizedColumnWidths: Array<number | undefined>;\n  initialColumnWidths: number[];\n}): number => {\n  const selectedColumns = initialColumnWidths\n    .slice(0, columnIndex)\n    .map((size, index) => resizedColumnWidths[index] || size);\n\n  return selectedColumns.reduce((acc, column) => acc + column, 0);\n};\n\nexport const createSortingState = <T extends TableRow>(\n  by: keyof T,\n  order?: OrderType,\n  sortFn?: (a: T[keyof T], b: T[keyof T]) => number,\n): SortingState<T> => {\n  if (!isString(order)) {\n    return null;\n  }\n\n  return { by, order: order.toLowerCase(), sortFn } as SortingState<T>;\n};\n\nexport const getNewSorting = <T extends TableRow>(\n  currentSorting: SortingState<T>,\n  newField: keyof T,\n  sortFn?: (a: T[keyof T], b: T[keyof T]) => number,\n): SortingState<T> => {\n  if (!currentSorting || currentSorting.by !== newField) {\n    return {\n      by: newField,\n      order: 'asc',\n      sortFn,\n    };\n  }\n\n  if (currentSorting.order === 'asc') {\n    return {\n      by: newField,\n      order: 'desc',\n      sortFn,\n    };\n  }\n\n  return null;\n};\n\nexport const getMaxLevel = <T extends TableRow>(\n  columns: Array<TableColumn<T>>,\n) => {\n  let count = 0;\n\n  const traverse = (cols: Array<TableColumn<T>>, level = 1) => {\n    if (level > count) count = level;\n    cols.forEach((item: TableColumn<T>) => {\n      if (item.columns) {\n        traverse(item.columns, level + 1);\n      }\n    });\n  };\n\n  traverse(columns);\n\n  return count;\n};\n\nconst getLastChildrenCount = <T extends TableRow>(\n  columns: Array<TableColumn<T>>,\n) => {\n  let count = 0;\n\n  const traverse = (cols: Array<TableColumn<T>>) => {\n    cols.forEach((item: TableColumn<T>) => {\n      if (item.columns) {\n        traverse(item.columns);\n      } else {\n        count++;\n      }\n    });\n  };\n\n  traverse(columns);\n\n  return count;\n};\n\nexport const transformColumns = <T extends TableRow>(\n  columns: Array<TableColumn<T>>,\n  maxLevel: number,\n): Array<Header<T>>[] => {\n  const stack = [{ columns, index: 0 }];\n  const headersArr: Array<Header<T>>[] = [];\n  let col = 0;\n\n  while (stack.length) {\n    const level = stack.length - 1;\n    const node = stack[level];\n    const item = node.columns[node.index] as Header<T>;\n\n    if (item) {\n      if (!headersArr[level]) headersArr[level] = [];\n      const topHeaderGridIndex = stack[0].index;\n      const prevItem = headersArr[level][headersArr[level].length - 1];\n      const gridIndex = prevItem\n        ? prevItem.position.gridIndex + (prevItem.position.colSpan || 1)\n        : 0;\n      const mainId = level === 0 ? col++ : item.colId ?? 0;\n\n      const handledItem: TableColumn<T> & {\n        position: Position;\n        colId?: number;\n        parentId?: number;\n      } = {\n        ...item,\n        position: {\n          topHeaderGridIndex,\n          gridIndex,\n          level,\n        },\n      };\n\n      if (level === 0) {\n        handledItem.colId = mainId;\n      }\n\n      if (!handledItem.columns) {\n        handledItem.position.rowSpan = maxLevel - level;\n        headersArr[level].push(handledItem);\n        node.index++;\n      } else {\n        handledItem.position.colSpan = getLastChildrenCount(\n          handledItem.columns,\n        );\n        headersArr[level].push(handledItem);\n        stack.push({\n          columns: handledItem.columns.map((el) => ({\n            ...el,\n            colId: col++,\n            parentId: mainId,\n          })),\n          index: 0,\n        });\n      }\n    } else {\n      stack.pop();\n      if (stack[stack.length - 1]) stack[stack.length - 1].index++;\n    }\n  }\n\n  return headersArr;\n};\n\nconst getIsFirst = <T extends TableRow>(\n  columns: Header<T>[],\n  column: Header<T>,\n): boolean => {\n  const { colId, parentId, position, accessor } = column;\n  if (position.level === 0) {\n    return colId === 0;\n  }\n  const parent = columns.find((el) => el.colId === parentId);\n  return !!(\n    parent?.columns?.[0]?.accessor === accessor &&\n    (parent ? getIsFirst(columns, parent) : false)\n  );\n};\n\n/**\n * Возвращает данные, необходимые для построения хидера таблицы\n *\n * @param columns - массив колонок\n *\n * @return {\n *   {Array<Header<T>>[]} headers: двумерный массив заголовков, выстроенный по вертикали;\n *   {Array<Header<T>>} flattenedHeaders: плоский массив заголовков;\n *   {Array<Header<T>>} lowHeaders: самые нижние заголовки (по ним строятся колонки);\n *   {Record<number, HTMLDivElement | null>} headerRowsRefs: содержит рефы на заголовки;\n *   {Array<number>} headerRowsHeights: массив высот строк заголовков;\n *   {Array<number>} headerColumnsHeights: массив высот колонок заголовков;\n *   {Array<number>} resizerTopOffsets: массив отступов для компонентов Resizer;\n * }\n */\nexport const useHeaderData = <T extends TableRow>(\n  columns: Array<TableColumn<T>>,\n): HeaderData<T> => {\n  const headerRowsRefs = React.useRef<Record<number, HTMLDivElement | null>>(\n    {},\n  );\n  const headers = transformColumns(columns, getMaxLevel(columns));\n  const headerColumnsHeights: Array<number> = Object.values(\n    headerRowsRefs.current,\n  )\n    .filter(isNotNil)\n    .map((ref) => ref.getBoundingClientRect().height);\n\n  const flattenedHeaders = headers\n    .flat()\n    .filter((column: TableColumn<T>) => !column.hidden)\n    .map((column, index, array) => ({\n      ...column,\n      position: {\n        ...column.position,\n        isFirst: getIsFirst(array, column),\n        smallTextSize:\n          headers.length > 1 && column.position.level === headers.length - 1,\n        height: headerColumnsHeights[index] || 0,\n      },\n    }));\n  const headerRowsHeights = headers.map((arr, index) => {\n    return Math.min.apply(\n      null,\n      flattenedHeaders\n        .filter(\n          (col: TableColumn<T> & { position: Position }) =>\n            col.position.level === index,\n        )\n        .map((item) => item.position.height),\n    );\n  });\n  const lowHeaders = flattenedHeaders\n    .filter(\n      ({ position: { colSpan } }: TableColumn<T> & { position: Position }) =>\n        !colSpan,\n    )\n    .sort((a, b) => {\n      if (a.position.topHeaderGridIndex !== b.position.topHeaderGridIndex) {\n        return a.position.topHeaderGridIndex > b.position.topHeaderGridIndex\n          ? 1\n          : -1;\n      }\n      return a.position.gridIndex > b.position.gridIndex ? 1 : -1;\n    });\n\n  const resizerTopOffsets = lowHeaders.map(\n    (header: TableColumn<T> & { position: Position }, index: number) => {\n      const headerHeight = headerRowsHeights.reduce(\n        (a: number, b: number) => a + b,\n        0,\n      );\n      if (\n        (header.position.rowSpan || 0) >=\n        (lowHeaders[index + 1]?.position.rowSpan || 0)\n      ) {\n        return headerHeight - (header.position.height || 0);\n      }\n      // eslint-disable-next-line no-unsafe-optional-chaining\n      return headerHeight - lowHeaders[index + 1]?.position.height! || 0;\n    },\n  );\n\n  return {\n    headers,\n    flattenedHeaders,\n    lowHeaders,\n    headerRowsRefs,\n    headerRowsHeights,\n    headerColumnsHeights,\n    resizerTopOffsets,\n  };\n};\n\n/**\n * Возвращает 2 функции, необходимые для отображения большого количества строк в таблице\n *\n * @param maxVisibleRows - максимальное количество отображаемых строк в один момент времени\n * @param scrollableEl - элемент, на который вешается scroll listener\n * @param enabled - флаг включения данной функциональность\n *\n * @return {\n *   getSlicedRows: функция, обрезающая исходный массив данных\n *   setBoundaryRef: функция, проставляющая рефы необходимым ячейкам для вычисления границ отображения строк\n * }\n */\nexport const useLazyLoadData = (\n  maxVisibleRows: number,\n  scrollableEl: HTMLDivElement | Window | null,\n  enabled: boolean,\n) => {\n  const [visibleStartIndex, setVisibleStartIndex] = React.useState<number>(0);\n  const cellsRefStart = React.useRef<HTMLDivElement>(null);\n  const cellsRefEnd = React.useRef<HTMLDivElement>(null);\n  const additionalRowsCount = Math.floor(maxVisibleRows / 3);\n\n  React.useEffect(() => {\n    if (!enabled) return;\n    let elHeight = 0;\n    if (scrollableEl && 'offsetHeight' in scrollableEl) {\n      elHeight = scrollableEl.offsetHeight;\n    } else if (scrollableEl && 'outerHeight' in scrollableEl) {\n      elHeight = scrollableEl.outerHeight;\n    }\n    const onScrollListener = () => {\n      if (\n        cellsRefEnd.current &&\n        elHeight / 2 > cellsRefEnd.current.getBoundingClientRect().top\n      ) {\n        setVisibleStartIndex((prevIndex) => prevIndex + additionalRowsCount);\n      } else if (\n        cellsRefStart.current &&\n        cellsRefStart.current.getBoundingClientRect().top > elHeight / 2\n      ) {\n        setVisibleStartIndex((prevIndex) =>\n          prevIndex - additionalRowsCount < 0\n            ? 0\n            : prevIndex - additionalRowsCount,\n        );\n      }\n    };\n\n    scrollableEl?.addEventListener('scroll', onScrollListener);\n\n    return () => scrollableEl?.removeEventListener('scroll', onScrollListener);\n  }, [visibleStartIndex, scrollableEl]);\n\n  const setBoundaryRef = (columnIdx: number, rowIdx: number) => {\n    if (\n      enabled &&\n      columnIdx === 0 &&\n      rowIdx === additionalRowsCount &&\n      visibleStartIndex > 0\n    ) {\n      return cellsRefStart;\n    }\n    if (\n      enabled &&\n      columnIdx === 0 &&\n      rowIdx === maxVisibleRows - additionalRowsCount\n    ) {\n      return cellsRefEnd;\n    }\n    return undefined;\n  };\n\n  const getSlicedRows = <T extends TableRow>(rows: T[]) =>\n    !enabled || rows.length < maxVisibleRows\n      ? rows\n      : rows.slice(visibleStartIndex, visibleStartIndex + maxVisibleRows);\n\n  return {\n    getSlicedRows,\n    setBoundaryRef,\n  };\n};\n\nexport const transformRows = <T extends TableRow>(\n  rows: T[],\n  expandedRowIds: string[],\n  isTableExpanded?: boolean,\n): TableTreeRow<T>[] => {\n  const stack = [{ rows, index: 0 }];\n  const rowsArr: TableTreeRow<T>[] = [];\n  while (stack.length) {\n    const level = stack.length - 1;\n    const node = stack[level];\n    const item: T = node.rows[node.index];\n\n    if (item) {\n      const handledItem: TableTreeRow<T> = {\n        ...item,\n        options: { level },\n        rows: item.rows && [...item.rows],\n      };\n\n      const needGoDeeper =\n        Boolean(handledItem.rows) &&\n        (isTableExpanded || expandedRowIds.includes(handledItem.id));\n\n      if (needGoDeeper) {\n        stack.push({ rows: handledItem.rows as T[], index: 0 });\n      } else {\n        node.index++;\n      }\n\n      rowsArr.push(handledItem);\n    } else {\n      stack.pop();\n      if (stack[stack.length - 1]) {\n        stack[stack.length - 1].index++;\n      }\n    }\n  }\n  return rowsArr;\n};\n\nexport function getMergedArray<TYPE>(mainArr: TYPE[], mergeArr: TYPE[]) {\n  const length = Math.max(mainArr.length, mergeArr.length);\n  const resultArr: TYPE[] = [];\n  for (let i = 0; i < length; i++) {\n    resultArr.push(mergeArr[i] ?? mainArr[i]);\n  }\n  return resultArr;\n}\n\nexport function calulateColSpans<T extends TableRow>(\n  columns: TableColumn<T>[],\n  row: TableTreeRow<T>,\n) {\n  const spans: number[] = [];\n  let counter = 0;\n  const { length } = columns;\n  const getAvailableSpan = (span: number, size: number) => {\n    if (size + span > length) return length - size - span;\n    return span;\n  };\n  columns.forEach((column) => {\n    const { colSpan } = column;\n    const size = spans.length > 1 ? spans.reduce((a, b) => a + b) : 0;\n    if (typeof colSpan === 'number' || typeof colSpan === 'function') {\n      const span = typeof colSpan === 'number' ? colSpan : colSpan(row);\n      if (counter === 0) {\n        spans.push(getAvailableSpan(span, size));\n      } else {\n        spans.push(getAvailableSpan(span - counter || 0, size));\n      }\n      counter = span - counter > 0 ? span - 1 : counter - span;\n    } else if (counter !== 0) {\n      spans.push(0);\n      counter--;\n    } else {\n      spans.push(getAvailableSpan(1, size));\n    }\n  });\n  return spans;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}