{"ast":null,"code":"function _createForOfIteratorHelper(a, b) {\n  var c = \"undefined\" != typeof Symbol && a[Symbol.iterator] || a[\"@@iterator\"];\n  if (!c) {\n    if (Array.isArray(a) || (c = _unsupportedIterableToArray(a)) || b && a && \"number\" == typeof a.length) {\n      c && (a = c);\n      var d = 0,\n        e = function () {};\n      return {\n        s: e,\n        n: function n() {\n          return d >= a.length ? {\n            done: !0\n          } : {\n            done: !1,\n            value: a[d++]\n          };\n        },\n        e: function e(a) {\n          throw a;\n        },\n        f: e\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var f,\n    g = !0,\n    h = !1;\n  return {\n    s: function s() {\n      c = c.call(a);\n    },\n    n: function n() {\n      var a = c.next();\n      return g = a.done, a;\n    },\n    e: function e(a) {\n      h = !0, f = a;\n    },\n    f: function f() {\n      try {\n        g || null == c[\"return\"] || c[\"return\"]();\n      } finally {\n        if (h) throw f;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(a, b) {\n  if (a) {\n    if (\"string\" == typeof a) return _arrayLikeToArray(a, b);\n    var c = Object.prototype.toString.call(a).slice(8, -1);\n    return \"Object\" === c && a.constructor && (c = a.constructor.name), \"Map\" === c || \"Set\" === c ? Array.from(a) : \"Arguments\" === c || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(c) ? _arrayLikeToArray(a, b) : void 0;\n  }\n}\nfunction _arrayLikeToArray(a, b) {\n  (null == b || b > a.length) && (b = a.length);\n  for (var c = 0, d = Array(b); c < b; c++) d[c] = a[c];\n  return d;\n}\nimport { useMemo } from \"react\";\nimport { setRef } from \"../../utils/setRef\";\nexport var forkRef = function (a) {\n  return a.length ? function (b) {\n    var c,\n      d = _createForOfIteratorHelper(a);\n    try {\n      for (d.s(); !(c = d.n()).done;) {\n        var e = c.value;\n        setRef(e, b);\n      }\n    } catch (a) {\n      d.e(a);\n    } finally {\n      d.f();\n    }\n  } : null;\n};\nexport var useForkRef = function (a) {\n  return useMemo(function () {\n    return forkRef(a);\n  }, [a]);\n};","map":{"version":3,"names":["useMemo","setRef","forkRef","a","length","b","c","d","_createForOfIteratorHelper","s","n","done","e","value","f","useForkRef"],"sources":["/Users/leonofv/Documents/GitHub/PurchasesProject/purchase-ui/node_modules/@consta/src/hooks/useForkRef/useForkRef.ts"],"sourcesContent":["import { useMemo } from 'react';\n\nimport { setRef } from '##/utils/setRef';\n\nexport const forkRef = <T>(\n  refs: (React.Ref<T> | undefined)[],\n): React.RefCallback<T> | null => {\n  if (!refs.length) {\n    return null;\n  }\n  return (refValue) => {\n    for (const ref of refs) {\n      setRef(ref as React.MutableRefObject<T>, refValue);\n    }\n  };\n};\n\nexport const useForkRef = <T>(refs: (React.Ref<T> | undefined)[]) =>\n  useMemo(() => forkRef(refs), [refs]);\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAASA,OAAT,QAAwB,OAAxB;AAEA,SAASC,MAAT;AAEA,OAAO,IAAMC,OAAO,GAAG,SAAAA,CACrBC,CADqB,EAEW;EAAA,OAC3BA,CAAI,CAACC,MADsB,GAIzB,UAACC,CAAD,EAAc;IAAA,IAAAC,CAAA;MAAAC,CAAA,GAAAC,0BAAA,CACDL,CADC;IAAA;MACnB,KAAAI,CAAA,CAAAE,CAAA,MAAAH,CAAA,GAAAC,CAAA,CAAAG,CAAA,IAAAC,IAAA,GAAwB;QAAA,IAAbC,CAAa,GAAAN,CAAA,CAAAO,KAAA;QACtBZ,MAAM,CAACW,CAAD,EAAmCP,CAAnC,CACP;MAAA;IAHkB,SAAAF,CAAA;MAAAI,CAAA,CAAAK,CAAA,CAAAT,CAAA;IAAA;MAAAI,CAAA,CAAAO,CAAA;IAAA;EAIpB,CAR+B,GAEvB,IAOV;AAAA,CAXM;AAaP,OAAO,IAAMC,UAAU,GAAG,SAAAA,CAAIZ,CAAJ;EAAA,OACxBH,OAAO,CAAC;IAAA,OAAME,OAAO,CAACC,CAAD,CAAb;EAAA,CAAD,EAAsB,CAACA,CAAD,CAAtB,CADiB;AAAA,CAAnB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}